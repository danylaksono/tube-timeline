<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='UTF-8' />
  <title>Interactive Timeline</title>
  <script src='https://d3js.org/d3.v7.min.js'></script>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
    }

    svg {
      width: 100%;
      height: 100vh;
      background: #f9f9f9;
    }

    .milestone-icon {
      font-size: 16px;
      cursor: pointer;
      text-anchor: middle;
      alignment-baseline: middle;
    }

    .milestone-label {
      font-size: 12px;
      text-anchor: middle;
    }

    .track-line {
      stroke-width: 20;
      opacity: 1;
    }

    .today-line {
      stroke: #888;
      stroke-width: 3;
      stroke-dasharray: 4;
    }
  </style>
</head>

<body>
  <svg></svg>

  <script>const data = [
      {
        track: 'Full Papers',
        label: 'FP',
        color: '#1F77B4', // Bright blue
        dates: [
          { date: '27/11/2025', name: 'Abstract deadline', type: 'start', url: 'https://eurovis.org.uk/full-papers/', label: 'Abstract' },
          { date: '04/12/2025', name: 'Full paper deadline', type: 'submission', url: 'https://eurovis.org.uk/full-papers/', label: 'Submission' },
          { date: '12/02/2026', name: 'First Round Notification', type: 'notification', url: 'https://eurovis.org.uk/full-papers/', label: 'Notification' },
          { date: '05/03/2026', name: 'Revised Submission', type: 'submission', url: 'https://eurovis.org.uk/full-papers/', label: 'Revision' },
          { date: '19/03/2026', name: 'Final Notification', type: 'notification', url: 'https://eurovis.org.uk/full-papers/', label: 'Notification' },
          { date: '16/04/2026', name: 'Camera Ready Version', type: 'end', url: 'https://eurovis.org.uk/full-papers/', label: 'Camera Ready' }
        ]
      },
      {
        track: 'Short Papers',
        label: 'SP',
        color: '#E377C2', // Vivid red
        dates: [
          { date: '19/02/2026', name: 'Submission deadline', type: 'start', url: 'https://eurovis.org.uk/short-papers/', label: 'Submission' },
          { date: '02/04/2026', name: 'Acceptance notification', type: 'notification', url: 'https://eurovis.org.uk/short-papers/', label: 'Notification' },
          { date: '23/04/2026', name: 'Camera Ready Version', type: 'end', url: 'https://eurovis.org.uk/short-papers/', label: 'Camera Ready' }
        ]
      },
      {
        track: 'State of the Art Reports',
        label: 'STAR',
        color: '#FFDD44', // Bright green
        dates: [
          { date: '13/10/2025', name: 'STAR Sketch Submission', type: 'start', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Sketch' },
          { date: '05/11/2025', name: 'Invitation for Full STAR', type: 'notification', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Invitation' },
          { date: '12/01/2026', name: 'Full STAR Submission', type: 'submission', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Submission' },
          { date: '05/03/2026', name: 'Full STAR Notification', type: 'notification', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Notification' },
          { date: '25/03/2026', name: 'Second Round Submission', type: 'submission', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Revision' },
          { date: '08/04/2026', name: 'Second Review Notification', type: 'notification', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Notification' },
          { date: '22/04/2026', name: 'Camera-Ready Deadline', type: 'end', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Camera Ready' }
        ]
      },
      {
        track: 'Panels & Tutorials',
        label: 'P&T',
        color: '#2CA02C', // Punchy yellow
        dates: [
          { date: '26/02/2026', name: 'Submission deadline', type: 'start', url: 'https://eurovis.org.uk/panels-and-tutorials/', label: 'Submission' },
          { date: '05/03/2026', name: 'Conditional Notification', type: 'notification', url: 'https://eurovis.org.uk/panels-and-tutorials/', label: 'Notification' },
          { date: '16/04/2026', name: 'Camera-Ready Abstract', type: 'end', url: 'https://eurovis.org.uk/panels-and-tutorials/', label: 'Camera Ready' }
        ]
      },
      {
        track: 'Workshops',
        label: 'WS',
        color: '#9467BD', // Vivid purple
        dates: [
          { date: '29/09/2025', name: 'Proposal Submission', type: 'start', url: 'https://eurovis.org.uk/workshops/', label: 'Submission' },
          { date: '15/10/2025', name: 'Notification', type: 'end', url: 'https://eurovis.org.uk/workshops/', label: 'Notification' }
        ]
      },
      {
        track: 'Education Papers',
        label: 'ED',
        color: '#17BECF', // Bright orange
        dates: [
          { date: '08/01/2026', name: 'Submission', type: 'start', url: 'https://eurovis.org.uk/education-papers/', label: 'Submission' },
          { date: '04/04/2026', name: 'Notification', type: 'notification', url: 'https://eurovis.org.uk/education-papers/', label: 'Notification' },
          { date: '25/04/2026', name: 'Camera-Ready', type: 'end', url: 'https://eurovis.org.uk/education-papers/', label: 'Camera Ready' }
        ]
      },
      {
        track: 'Posters & Demos',
        label: 'P&D',
        color: '#FF7F0E', // Bright cyan
        dates: [
          { date: '06/04/2026', name: 'Submission', type: 'start', url: 'https://eurovis.org.uk/posters/', label: 'Submission' },
          { date: '24/04/2026', name: 'Notification', type: 'notification', url: 'https://eurovis.org.uk/posters/', label: 'Notification' },
          { date: '30/04/2026', name: 'Camera-Ready', type: 'end', url: 'https://eurovis.org.uk/posters/', label: 'Camera Ready' }
        ]
      }
    ];

    const typeIcons = {
      start: 'ðŸ“„',     // For anything being submitted
      abstract: 'ðŸ“',         // For abstract deadlines
      submission: 'ðŸ“¬', // For submission deadlines
      review: 'ðŸ”',         // For review phases (internal or external)
      notification: 'ðŸ“¢',   // For acceptance or review notifications
      cameraReady: 'ðŸ–¨ï¸',    // Specifically for final camera-ready submissions
      end: 'âœ…',         // For final deadlines or camera-ready versions
      invitation: 'âœ‰ï¸',     // For invitations to submit (e.g., for STARs)
    };

    const parseDate = str => {
      // Match DD/MM/YYYY or MM/YYYY
      const fullMatch = /^(\d{2})\/(\d{2})\/(\d{4})$/.exec(str);
      if (fullMatch) {
        return new Date(+fullMatch[3], +fullMatch[2] - 1, +fullMatch[1]);
      }
      const monthYearMatch = /^(\d{2})\/(\d{4})$/.exec(str);
      if (monthYearMatch) {
        return new Date(+monthYearMatch[2], +monthYearMatch[1] - 1, 1);
      }
      return null;
    };

    const today = new Date();
    data.forEach(track => track.dates.forEach(d => d.parsed = parseDate(d.date)));
    data.sort((a, b) => {
      const aStart = a.dates.find(d => d.type === 'start')?.parsed;
      const bStart = b.dates.find(d => d.type === 'start')?.parsed;
      return (aStart || new Date(9999, 0, 1)) - (bStart || new Date(9999, 0, 1));
    });

    
    const allDates = [...new Set(data.flatMap(t => t.dates.map(d => d.parsed)))].sort((a, b) => a - b);
    const trackNames = data.map(d => d.track);
    const svg = d3.select('svg');
    const tooltip = d3.select('#tooltip');

    function renderHeader() {
      d3.select('.header-group').remove();
      const headerGroup = svg.append('g')
        .attr('class', 'header-group');

      // Logo image (top left)
      headerGroup.append('image')
        .attr('x', 10)
        .attr('y', 10)
        .attr('height', 80)
        .attr('href', 'logo.png')
        .attr('preserveAspectRatio', 'xMidYMid meet');

      // Title and subtitle (left, vertically stacked)
      headerGroup.append('text')
        .attr('x', 90)
        .attr('y', 50)
        .attr('text-anchor', 'start')
        .attr('font-size', 32)
        .attr('font-weight', 'bold')
        .attr('font-family', 'sans-serif')
        .attr('fill', '#222')
        .text('EuroVis 2026 Timeline');

      headerGroup.append('text')
        .attr('x', 90)
        .attr('y', 68)
        .attr('text-anchor', 'start')
        .attr('font-size', 18)
        .attr('font-family', 'sans-serif')
        .attr('fill', '#666')
        .text('Key Deadlines for All Tracks');

      // Subway-style legend (right, 2 columns)
      const legendSpacing = 28;
      const legendCols = 2;
      const legendRows = Math.ceil(data.length / legendCols);

      // Measure max text width per column for legend sizing
      let maxTextWidths = [0, 0];
      data.forEach((track, i) => {
        const col = i % legendCols;
        const tempText = headerGroup.append('text')
          .attr('x', 0)
          .attr('y', -100)
          .attr('font-size', 16)
          .attr('font-family', 'sans-serif')
          .text(track.track);
        const textWidth = tempText.node().getBBox().width;
        if (textWidth > maxTextWidths[col]) maxTextWidths[col] = textWidth;
        tempText.remove();
      });
      const colWidth = Math.max(...maxTextWidths) + 14;
      const legendRectWidth = legendCols * colWidth + 14;
      const legendHeight = legendRows * legendSpacing + 14;
      const legendPadding = 12;

      // Align legend to right edge with padding
      const legendX = svg.node().clientWidth - legendRectWidth - legendPadding;
      const legendY = 30;

      const legendGroup = headerGroup.append('g')
        .attr('class', 'subway-legend')
        .attr('transform', `translate(${legendX},${legendY})`);


      // Draw rect first
      legendGroup.append('rect')
        .attr('x', -legendPadding)
        .attr('y', -legendPadding)
        .attr('width', legendRectWidth)
        .attr('height', legendHeight)
        .attr('rx', 18)
        .attr('fill', '#fff')
        .attr('stroke', '#000')
        .attr('stroke-width', 4)
        .attr('opacity', 1);

      // Draw legend items in columns
      data.forEach((track, i) => {
        const col = i % legendCols;
        const row = Math.floor(i / legendCols);
        const xBase = col * colWidth;
        const yBase = row * legendSpacing + 8;

        legendGroup.append('line')
          .attr('x1', xBase)
          .attr('y1', yBase)
          .attr('x2', xBase + 16)
          .attr('y2', yBase)
          .attr('stroke', track.color)
          .attr('stroke-width', 8)
          .attr('stroke-linecap', 'round');
        legendGroup.append('text')
          .attr('x', xBase + 25)
          .attr('y', yBase + 6)
          .attr('font-size', 14)
          .attr('fill', '#222')
          .attr('font-family', 'sans-serif')
          .text(track.track);
      });
    }

    function render() {
      svg.selectAll('*').remove();

      renderHeader();

      const isHorizontal = window.innerWidth >= window.innerHeight;
      const margin = { top: 40, right: 50, bottom: 40, left: 50 };
      const width = svg.node().clientWidth - margin.left - margin.right;
      const height = svg.node().clientHeight - margin.top - margin.bottom;

      // Push the main group down to leave space for the header
      const headerHeight = 100;
      const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top + headerHeight})`);
      // Reduce spacing between lanes
      let xScale, yScale;

      if (isHorizontal) {
        xScale = d3.scaleTime().domain(d3.extent(allDates)).range([margin.left, width]);
        const laneCount = trackNames.length;
        yScale = d3.scalePoint().domain(trackNames).range([16, height - 16]).padding(0);

        g.selectAll('.track-line')
          .data(data)
          .enter()
          .append('line')
          .attr('class', 'track-line')
          .attr('x1', d => {
            const startDateObj = d.dates.find(date => date.type === 'start');
            return startDateObj ? xScale(startDateObj.parsed) : 0;
          })
          .attr('x2', d => {
            const endDateObj = d.dates.find(date => date.type === 'end');
            return endDateObj ? xScale(endDateObj.parsed) : xScale(d.dates[d.dates.length - 1].parsed);
          })
          .attr('y1', d => yScale(d.track))
          .attr('y2', d => yScale(d.track))
          .attr('stroke', d => d.color);

        g.selectAll('.track-label')
          .data(data)
          .enter()
          .append('text')
          .attr('class', 'track-label')
          .attr('x', 15)
          .attr('y', d => yScale(d.track))
          .attr('dy', '0.35em')
          .attr('text-anchor', 'end')
          .attr('font-weight', 'bold')
          .attr('fill', d => d.color)
          .text(d => d.label || d.track)
          .on('mouseover', function (event, d) {
            showSvgTooltip(g, isHorizontal ? 0 : 15, yScale(d.track), `<strong>${d.track}</strong>`, isHorizontal);
          })
          .on('mousemove', function (event, d) {
            showSvgTooltip(g, isHorizontal ? 0 : 15, yScale(d.track), `<strong>${d.track}</strong>`, isHorizontal);
          })
          .on('mouseout', () => {
            removeSvgTooltip(g);
          });

      } else {
        const laneCount = trackNames.length;
        xScale = d3.scalePoint().domain(trackNames).range([16, width - 16]).padding(0);
        yScale = d3.scaleTime().domain(d3.extent(allDates)).range([0, height]);

        g.selectAll('.track-line')
          .data(data)
          .enter()
          .append('line')
          .attr('class', 'track-line')
          .attr('y1', d => {
            const startDateObj = d.dates.find(date => date.type === 'start');
            return startDateObj ? yScale(startDateObj.parsed) : 0;
          })
          .attr('y2', d => {
            const endDateObj = d.dates.find(date => date.type === 'end');
            return endDateObj ? yScale(endDateObj.parsed) : yScale(d.dates[d.dates.length - 1].parsed);
          })
          .attr('x1', d => xScale(d.track))
          .attr('x2', d => xScale(d.track))
          .attr('stroke', d => d.color);

        g.selectAll('.track-label')
          .data(data)
          .enter()
          .append('text')
          .attr('class', 'track-label')
          .attr('x', d => xScale(d.track))
          .attr('y', -15)
          .attr('text-anchor', 'middle')
          .attr('font-weight', 'bold')
          .attr('fill', d => d.color)
          .text(d => d.label || d.track)
          .on('mouseover', function (event, d) {
            showSvgTooltip(g, xScale(d.track), -15, `<strong>${d.track}</strong>`, false, true);
          })
          .on('mousemove', function (event, d) {
            showSvgTooltip(g, xScale(d.track), -15, `<strong>${d.track}</strong>`, false, true);
          })
          .on('mouseout', () => {
            removeSvgTooltip(g);
          });
      }

      // Draw milestones
      data.forEach(track => {
        const pos = isHorizontal
          ? { fixed: yScale(track.track), axis: d => xScale(d.parsed) }
          : { fixed: xScale(track.track), axis: d => yScale(d.parsed) };

        g.selectAll()
          .data(track.dates)
          .enter()
          .append('g')
          .attr('transform', d => {
            const x = isHorizontal ? pos.axis(d) : pos.fixed;
            const y = isHorizontal ? pos.fixed : pos.axis(d);
            return `translate(${x},${y})`;
          })
          .each(function (d) {
            // Background circle (thicker black stroke)
            d3.select(this)
              .append('circle')
              .attr('r', 20)
              .attr('fill', '#fff')
              .attr('stroke', '#000')
              .attr('stroke-width', 5);

            d3.select(this)
              .append('circle')
              .attr('r', 16)
              .attr('fill', '#fff');
              // .attr('stroke', track.color)
              // .attr('stroke-width', 2);

            d3.select(this)
              .append('text')
              .attr('class', 'milestone-icon')
              .attr('dy', '0.35em')
              .text(typeIcons[d.type]);
          })
          .on('mouseover', function (event, d) {
            const coords = d3.select(this).attr('transform').match(/translate\(([^,]+),([^)]+)\)/);
            const x = +coords[1];
            const y = +coords[2];
            showSvgTooltip(g, x, y, `<strong>${d.name}</strong><br>${d.date}`, isHorizontal);
          })
          .on('mousemove', function (event, d) {
            const coords = d3.select(this).attr('transform').match(/translate\(([^,]+),([^)]+)\)/);
            const x = +coords[1];
            const y = +coords[2];
            showSvgTooltip(g, x, y, `<strong>${d.name}</strong><br>${d.date}`, isHorizontal);
          })
          .on('mouseout', () => {
            removeSvgTooltip(g);
          })
          .on('click', (_, d) => {
            if (d.url) window.open(d.url, '_blank');
          });
      });

      // Draw background ticks for months
      const months = d3.timeMonths(
        d3.timeMonth.ceil(allDates[0]),
        d3.timeMonth.offset(d3.timeMonth.ceil(allDates[allDates.length - 1]), 1)
      );

      if (isHorizontal) {
        g.selectAll('.month-tick')
          .data(months)
          .enter()
          .append('line')
          .attr('class', 'month-tick')
          .attr('x1', d => xScale(d))
          .attr('x2', d => xScale(d))
          .attr('y1', 0)
          .attr('y2', height)
          .attr('stroke', '#ddd')
          .attr('stroke-width', 1);

        g.selectAll('.month-label')
          .data(months)
          .enter()
          .append('text')
          .attr('class', 'month-label')
          .attr('x', d => xScale(d))
          .attr('y', -10)
          .attr('text-anchor', 'middle')
          .attr('font-size', 11)
          .attr('fill', '#bbb')
          .text(d => d3.timeFormat('%b')(d));
      } else {
        g.selectAll('.month-tick')
          .data(months)
          .enter()
          .append('line')
          .attr('class', 'month-tick')
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('x1', 0)
          .attr('x2', width)
          .attr('stroke', '#ddd')
          .attr('stroke-width', 1);

        g.selectAll('.month-label')
          .data(months)
          .enter()
          .append('text')
          .attr('class', 'month-label')
          .attr('x', -10)
          .attr('y', d => yScale(d) + 4)
          .attr('text-anchor', 'end')
          .attr('font-size', 11)
          .attr('fill', '#bbb')
          .text(d => d3.timeFormat('%b')(d));
      }

      svg.selectAll('.legend-group').remove();

      const legendData = Object.entries(typeIcons);
      const legendGroup = svg.append('g')
        .attr('class', 'legend-group');
      const legendPadding = 5;
      const legendHeight = 30;
      const legendY = svg.node().clientHeight - legendHeight - legendPadding;
      const legendX = margin.left;
      const legendWidth = svg.node().clientWidth - margin.left - margin.right;
      const itemCount = legendData.length;
      const itemSpacing = legendWidth / itemCount;
      const iconY = legendY + legendHeight / 2 - 2;
      const labelY = iconY + 16;

      legendData.forEach((d, i) => {
        const itemX = legendX + itemSpacing * i + itemSpacing / 2;
        legendGroup.append('text')
          .attr('x', itemX)
          .attr('y', iconY)
          .attr('font-size', 14)
          .attr('text-anchor', 'middle')
          .text(d[1]);
        legendGroup.append('text')
          .attr('x', itemX)
          .attr('y', labelY)
          .attr('font-size', 10)
          .attr('text-anchor', 'middle')
          .text(d[0].charAt(0).toUpperCase() + d[0].slice(1));
      });

      // set today to the future for testing purposes
      const today = new Date('2025-01-01'); // Uncomment to test
      if (today >= allDates[0] && today <= allDates[allDates.length - 1]) {
        const linePos = isHorizontal ? xScale(today) : yScale(today);
        g.append('line')
          .attr('class', 'today-line')
          .attr(isHorizontal ? 'x1' : 'y1', linePos)
          .attr(isHorizontal ? 'x2' : 'y2', linePos)
          .attr(isHorizontal ? 'y1' : 'x1', 0)
          .attr(isHorizontal ? 'y2' : 'x2', isHorizontal ? height : width);
      }

      g.selectAll('.today-line').lower();
      g.selectAll('.track-line').raise();
      g.selectAll('.track-label').raise();
      g.selectAll('g').raise();
    }
    // SVG tooltip helpers
    function showSvgTooltip(g, x, y, html, isHorizontal, isLabel = false) {
      removeSvgTooltip(g);

      // Estimate width/height from text
      const text = html.replace(/<br>/g, ' ').replace(/<[^>]+>/g, '');
      const fontSize = 13;
      const padding = 10;
      const lineHeight = 18;
      const lines = html.split('<br>');
      const width = Math.max(80, text.length * fontSize * 0.5);
      const height = lines.length * lineHeight + padding * 2;

      // Position tooltip above or below the element
      let tooltipX = x;
      let tooltipY = y;

      if (isHorizontal) {
      tooltipY -= height + 18;
      if (tooltipY < 0) {
        tooltipY = y + 24;
      }
      } else {
      tooltipX += 24;
      tooltipY -= height / 2;
      if (tooltipX + width > g.node().ownerSVGElement.clientWidth) {
        tooltipX = x - width - 24;
      }
      if (isLabel) {
        tooltipY += 20;
      }
      }

      const tooltipGroup = g.append('g')
      .attr('class', 'svg-tooltip')
      .attr('pointer-events', 'none');

      tooltipGroup.append('rect')
      .attr('x', tooltipX - width / 2)
      .attr('y', tooltipY)
      .attr('width', width)
      .attr('height', height)
      .attr('rx', 8)
      .attr('fill', '#333')
      .attr('stroke', '#222')
      .attr('opacity', 0.95);

      // Text
      lines.forEach((line, i) => {
      tooltipGroup.append('text')
        .attr('x', tooltipX)
        .attr('y', tooltipY + padding + (i + 1) * lineHeight - 6)
        .attr('text-anchor', 'middle')
        .attr('font-size', fontSize)
        .attr('fill', '#fff')
        .attr('font-family', 'sans-serif')
        .html(line.replace(/<[^>]+>/g, ''));
      });
    }

    function removeSvgTooltip(g) {
      g.selectAll('.svg-tooltip').remove();
    }

    render();
    window.addEventListener('resize', render);
  </script>
</body>

</html>