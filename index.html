<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EuroVis 2026 Timeline üê•</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    svg { width: 100%; height: 100vh; background: #fff; }
    .today-line { stroke: #888; stroke-width: 3; stroke-dasharray: 4; }
    .footer {
      position: absolute; 
      bottom: 2px; 
      left: 5px; 
      font-size: 14px; 
      color: #000;
    }
    .footer svg {
      width: 22px;
      height: 22px;
    }
  </style>
</head>
<body>
  <svg></svg>

  <script>const data = [
      {
        track: 'Full Papers',
        label: 'FP',
        color: '#E32017', // Bright red
        dates: [
          { date: '27/11/2025', name: 'Abstract deadline', type: 'start', url: 'https://eurovis.org.uk/full-papers/', label: 'Abstract' },
          { date: '04/12/2025', name: 'Full paper deadline', type: 'submission', url: 'https://eurovis.org.uk/full-papers/', label: 'Submission' },
          { date: '12/02/2026', name: 'First Round Notification', type: 'notification', url: 'https://eurovis.org.uk/full-papers/', label: 'Notification' },
          { date: '05/03/2026', name: 'Revised Submission', type: 'submission', url: 'https://eurovis.org.uk/full-papers/', label: 'Revision' },
          { date: '19/03/2026', name: 'Final Notification', type: 'notification', url: 'https://eurovis.org.uk/full-papers/', label: 'Notification' },
          { date: '16/04/2026', name: 'Camera Ready Version', type: 'end', url: 'https://eurovis.org.uk/full-papers/', label: 'Camera Ready' }
        ]
      },
      {
        track: 'Short Papers',
        label: 'SP',
        color: '#B36305', // Orange-ish
        dates: [
          { date: '19/02/2026', name: 'Submission deadline', type: 'start', url: 'https://eurovis.org.uk/short-papers/', label: 'Submission' },
          { date: '02/04/2026', name: 'Acceptance notification', type: 'notification', url: 'https://eurovis.org.uk/short-papers/', label: 'Notification' },
          { date: '23/04/2026', name: 'Camera Ready Version', type: 'end', url: 'https://eurovis.org.uk/short-papers/', label: 'Camera Ready' }
        ]
      },
      {
        track: 'State of the Art Reports',
        label: 'STAR',
        color: '#FFD300', // Bright yellow
        dates: [
          { date: '13/10/2025', name: 'STAR Sketch Submission', type: 'start', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Sketch' },
          { date: '05/11/2025', name: 'Invitation for Full STAR', type: 'notification', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Invitation' },
          { date: '12/01/2026', name: 'Full STAR Submission', type: 'submission', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Submission' },
          { date: '05/03/2026', name: 'Full STAR Notification', type: 'notification', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Notification' },
          { date: '25/03/2026', name: 'Second Round Submission', type: 'submission', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Revision' },
          { date: '08/04/2026', name: 'Second Review Notification', type: 'notification', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Notification' },
          { date: '22/04/2026', name: 'Camera-Ready Deadline', type: 'end', url: 'https://eurovis.org.uk/state-of-the-art-reports-stars/', label: 'Camera Ready' }
        ]
      },
      {
        track: 'Panels & Tutorials',
        label: 'P&T',
        color: '#003688', // Dark blue
        dates: [
          { date: '26/02/2026', name: 'Submission deadline', type: 'start', url: 'https://eurovis.org.uk/panels-and-tutorials/', label: 'Submission' },
          { date: '05/03/2026', name: 'Conditional Notification', type: 'notification', url: 'https://eurovis.org.uk/panels-and-tutorials/', label: 'Notification' },
          { date: '16/04/2026', name: 'Camera-Ready Abstract', type: 'end', url: 'https://eurovis.org.uk/panels-and-tutorials/', label: 'Camera Ready' }
        ]
      },
      {
        track: 'Workshops',
        label: 'WS',
        color: '#00782A', // Vivid green
        dates: [
          { date: '29/09/2025', name: 'Proposal Submission', type: 'start', url: 'https://eurovis.org.uk/workshops/', label: 'Submission' },
          { date: '15/10/2025', name: 'Notification', type: 'end', url: 'https://eurovis.org.uk/workshops/', label: 'Notification' }
        ]
      },
      {
        track: 'Education Papers',
        label: 'ED',
        color: '#9B0056', // Dark magenta
        dates: [
          { date: '08/01/2026', name: 'Submission', type: 'start', url: 'https://eurovis.org.uk/education-papers/', label: 'Submission' },
          { date: '04/04/2026', name: 'Notification', type: 'notification', url: 'https://eurovis.org.uk/education-papers/', label: 'Notification' },
          { date: '25/04/2026', name: 'Camera-Ready', type: 'end', url: 'https://eurovis.org.uk/education-papers/', label: 'Camera Ready' }
        ]
      },
      {
        track: 'Posters & Demos',
        label: 'P&D',
        color: '#0098D4', // Light blue
        dates: [
          { date: '06/04/2026', name: 'Submission', type: 'start', url: 'https://eurovis.org.uk/posters/', label: 'Submission' },
          { date: '24/04/2026', name: 'Notification', type: 'notification', url: 'https://eurovis.org.uk/posters/', label: 'Notification' },
          { date: '30/04/2026', name: 'Camera-Ready', type: 'end', url: 'https://eurovis.org.uk/posters/', label: 'Camera Ready' }
        ]
      }
    ];

    const typeIcons = {
      start: 'üìÑ',     // For anything being submitted
      abstract: 'üìù',         // For abstract deadlines
      submission: 'üì¨', // For submission deadlines
      review: 'üîç',         // For review phases (internal or external)
      notification: 'üì¢',   // For acceptance or review notifications
      cameraReady: 'üñ®Ô∏è',    // Specifically for final camera-ready submissions
      end: '‚úÖ',         // For final deadlines or camera-ready versions
      invitation: '‚úâÔ∏è',     // For invitations to submit (e.g., for STARs)
    };

    const parseDate = str => {
      // Match DD/MM/YYYY or MM/YYYY
      const fullMatch = /^(\d{2})\/(\d{2})\/(\d{4})$/.exec(str);
      if (fullMatch) return new Date(+fullMatch[3], +fullMatch[2] - 1, +fullMatch[1]);
      const monthYearMatch = /^(\d{2})\/(\d{4})$/.exec(str);
      if (monthYearMatch) return new Date(+monthYearMatch[2], +monthYearMatch[1] - 1, 1);
      return null;
    }

    // --- Preprocessing ---
    data.forEach(track => track.dates.forEach(d => d.parsed = parseDate(d.date)));
    data.sort((a, b) => {
      const aStart = a.dates.find(d => d.type === 'start')?.parsed;
      const bStart = b.dates.find(d => d.type === 'start')?.parsed;
      return (aStart || new Date(9999, 0, 1)) - (bStart || new Date(9999, 0, 1));
    });
    const allDates = [...new Set(data.flatMap(t => t.dates.map(d => d.parsed)))].sort((a, b) => a - b);
    const trackNames = data.map(d => d.track);
    const svg = d3.select('svg');

    // --- Header Rendering ---
    function renderHeader() {
      d3.select('.header-group').remove();
      const headerGroup = svg.append('g').attr('class', 'header-group');
      headerGroup.append('image')
        .attr('x', 10).attr('y', 10).attr('height', 80)
        .attr('href', 'logo.png').attr('preserveAspectRatio', 'xMidYMid meet');
      headerGroup.append('text')
        .attr('x', 90).attr('y', 50).attr('text-anchor', 'start')
        .attr('font-size', 32).attr('font-weight', 'bold')
        .attr('font-family', 'sans-serif').attr('fill', '#222')
        .text('EuroVis 2026 Timeline');
      headerGroup.append('text')
        .attr('x', 90).attr('y', 68).attr('text-anchor', 'start')
        .attr('font-size', 18).attr('font-family', 'sans-serif')
        .attr('fill', '#666').text('Key Deadlines for All Tracks');

      // Legend
      const legendSpacing = 28, legendCols = 2;
      const legendRows = Math.ceil(data.length / legendCols);
      let maxTextWidths = [0, 0];
      data.forEach((track, i) => {
        const col = i % legendCols;
        const tempText = headerGroup.append('text')
          .attr('x', 0).attr('y', -100).attr('font-size', 16)
          .attr('font-family', 'sans-serif').text(track.track);
        const textWidth = tempText.node().getBBox().width;
        if (textWidth > maxTextWidths[col]) maxTextWidths[col] = textWidth;
        tempText.remove();
      });
      const isVertical = window.innerWidth < window.innerHeight;
      const colWidth = Math.max(...maxTextWidths) + (isVertical ? 5 : 14);
      const legendRectWidth = legendCols * colWidth + (isVertical ? 8 : 14);
      const legendHeight = legendRows * (isVertical ? 22 : legendSpacing) + (isVertical ? 8 : 14);
      const legendPadding = isVertical ? 8 : 12;
      const legendX = svg.node().clientWidth - legendRectWidth - legendPadding;
      const legendY = 30;
      const legendGroup = headerGroup.append('g')
        .attr('class', 'subway-legend')
        .attr('transform', `translate(${legendX},${legendY})`);
      legendGroup.append('rect')
        .attr('x', -legendPadding).attr('y', -legendPadding)
        .attr('width', legendRectWidth).attr('height', legendHeight)
        .attr('rx', 8).attr('fill', '#fff').attr('stroke', '#000')
        .attr('stroke-width', 3).attr('opacity', 1);
      data.forEach((track, i) => {
        const col = i % legendCols, row = Math.floor(i / legendCols);
        const xBase = col * colWidth, yBase = row * (isVertical ? 22 : legendSpacing) + (isVertical ? 4 : 8);
        legendGroup.append('line')
          .attr('x1', xBase).attr('y1', yBase)
          .attr('x2', xBase + 16).attr('y2', yBase)
          .attr('stroke', track.color).attr('stroke-width', 8)
          .attr('stroke-linecap', 'round');
        legendGroup.append('text')
          .attr('x', xBase + 25).attr('y', yBase + 6)
          .attr('font-size', 14).attr('fill', '#222')
          .attr('font-family', 'sans-serif').text(track.track);
      });
    }

    // --- Tooltip Helpers ---
    function showSvgTooltip(g, x, y, html, isHorizontal, isLabel = false) {
      removeSvgTooltip(g);
      const text = html.replace(/<br>/g, ' ').replace(/<[^>]+>/g, '');
      const fontSize = 13, padding = 10, lineHeight = 18;
      const lines = html.split('<br>');
      const width = Math.max(80, text.length * fontSize * 0.5);
      const height = lines.length * lineHeight + padding * 2;
      let tooltipX = x, tooltipY = y;
      if (isHorizontal) {
        tooltipY -= height + 18;
        if (tooltipY < 0) tooltipY = y + 24;
      } else {
        tooltipX += 24; tooltipY -= height / 2;
        if (tooltipX + width > g.node().ownerSVGElement.clientWidth) tooltipX = x - width - 24;
        if (isLabel) tooltipY += 20;
      }
      const tooltipGroup = g.append('g').attr('class', 'svg-tooltip').attr('pointer-events', 'none');
      tooltipGroup.append('rect')
        .attr('x', tooltipX - width / 2).attr('y', tooltipY)
        .attr('width', width).attr('height', height)
        .attr('rx', 8).attr('fill', '#333').attr('stroke', '#222').attr('opacity', 0.95);
      lines.forEach((line, i) => {
        tooltipGroup.append('text')
          .attr('x', tooltipX)
          .attr('y', tooltipY + padding + (i + 1) * lineHeight - 6)
          .attr('text-anchor', 'middle')
          .attr('font-size', fontSize)
          .attr('fill', '#fff')
          .attr('font-family', 'sans-serif')
          .html(line.replace(/<[^>]+>/g, ''));
      });
    }
    function removeSvgTooltip(g) {
      g.selectAll('.svg-tooltip').remove();
    }

    // --- Main Render ---
    function render() {
      svg.selectAll('*').remove();
      renderHeader();
      const isHorizontal = window.innerWidth >= window.innerHeight;
      const headerHeight = isHorizontal ? 130 : 90;
      const margin = { top: 40, right: 75, bottom: 40, left: 35 };
      const height = svg.node().clientHeight - margin.top - margin.bottom - headerHeight;
      const laneHeight = 15;
      const g = svg.append('g').attr('transform', `translate(${isHorizontal ? margin.left/2 : margin.left},${margin.top + headerHeight})`);
      const width = svg.node().clientWidth - (isHorizontal ? 0 : margin.left) - (isHorizontal ? margin.right : 1.5 * margin.right);

      let xScale, yScale;
      const trackLinesGroup = g.append('g')
        .attr('class', 'track-lines-group')
        .attr('transform', isHorizontal ?  'translate(0, 75)' : 'translate(0, 0)');

      if (isHorizontal) {
        xScale = d3.scaleTime().domain(d3.extent(allDates)).range([margin.left, width]);
        yScale = d3.scalePoint().domain(trackNames).range([10, height - 75]).padding(0);
        trackLinesGroup.selectAll('.track-line')
          .data(data).enter().append('line')
          .attr('class', 'track-line')
          .attr('x1', d => xScale(d.dates.find(date => date.type === 'start')?.parsed || d.dates[0].parsed))
          .attr('x2', d => xScale(d.dates.find(date => date.type === 'end')?.parsed || d.dates[d.dates.length - 1].parsed))
          .attr('y1', d => yScale(d.track)).attr('y2', d => yScale(d.track))
          .attr('stroke', d => d.color).attr('stroke-width', laneHeight).attr('stroke-linecap', 'round');
      } else {
        xScale = d3.scalePoint().domain(trackNames).range([16, width - 16]).padding(0);
        yScale = d3.scaleTime().domain(d3.extent(allDates)).range([0, height]);
        trackLinesGroup.selectAll('.track-line')
          .data(data).enter().append('line')
          .attr('class', 'track-line')
          .attr('y1', d => yScale(d.dates.find(date => date.type === 'start')?.parsed || d.dates[0].parsed))
          .attr('y2', d => yScale(d.dates.find(date => date.type === 'end')?.parsed || d.dates[d.dates.length - 1].parsed))
          .attr('x1', d => xScale(d.track)).attr('x2', d => xScale(d.track))
          .attr('stroke', d => d.color).attr('stroke-width', laneHeight).attr('stroke-linecap', 'round');
      }

      // Milestones
      data.forEach(track => {
        const pos = isHorizontal
          ? { fixed: yScale(track.track), axis: d => xScale(d.parsed) }
          : { fixed: xScale(track.track), axis: d => yScale(d.parsed) };
        trackLinesGroup.selectAll()
          .data(track.dates).enter().append('g')
          .attr('transform', d => {
            const x = isHorizontal ? pos.axis(d) : pos.fixed;
            const y = isHorizontal ? pos.fixed : pos.axis(d);
            return `translate(${x},${y})`;
          })
          .each(function (d) {
            if (d.type === 'start' || d.type === 'end') {
              d3.select(this).append('rect')
                .attr('x', isHorizontal ? -laneHeight : -laneHeight)
                .attr('y', isHorizontal ? -laneHeight*1.5 : -laneHeight * 0.625)
                .attr('width', isHorizontal ? laneHeight * 1.5 : laneHeight * 2)
                .attr('height', isHorizontal ? laneHeight * 3 : laneHeight * 1.25)
                .attr('fill', '#fff').attr('stroke', '#000').attr('stroke-width', 5)
                .attr('rx', 8).attr('ry', 8);
            } else {
              d3.select(this).append('rect')
                .attr('x', 0).attr('y', isHorizontal ? -laneHeight*2 : 0)
                .attr('width', isHorizontal ? laneHeight : laneHeight * 1.5)
                .attr('height', isHorizontal ? laneHeight * 2 : laneHeight)
                .attr('fill', track.color).attr('stroke', 'none')
                .attr('rx', 4).attr('ry', 4);
            }
            const labelLines = (d.label || '').split(' ');
            labelLines.forEach((line, i) => {
              const labelYOffset = isHorizontal ? -laneHeight * 2.75 + i * 16 : 5 + i * 16;
              const labelXOffset = isHorizontal ? 0 : laneHeight * 2.2;
              d3.select(this).append('text')
                .attr('class', 'milestone-label')
                .attr('text-anchor', 'start')
                .attr('font-size', 15).attr('font-weight', 'bold')
                .attr('font-family', 'sans-serif').attr('fill', '#222')
                .attr('x', labelXOffset).attr('y', labelYOffset)
                .attr('transform', `rotate(-30 ${labelXOffset} ${labelYOffset})`)
                .text(line);
            });
          })
          .on('mouseover', function (event, d) {
            const coords = d3.select(this).attr('transform').match(/translate\(([^,]+),([^)]+)\)/);
            const x = +coords[1], y = +coords[2];
            showSvgTooltip(g, x, y, `<strong>${d.name}</strong><br>${d.date}`, isHorizontal);
          })
          .on('mousemove', function (event, d) {
            const coords = d3.select(this).attr('transform').match(/translate\(([^,]+),([^)]+)\)/);
            const x = +coords[1], y = +coords[2];
            showSvgTooltip(g, x, y, `<strong>${d.name}</strong><br>${d.date}`, isHorizontal);
          })
          .on('mouseout', () => removeSvgTooltip(g))
          .on('click', (_, d) => { if (d.url) window.open(d.url, '_blank'); });
      });

      // Month ticks/labels
      const months = d3.timeMonths(
        d3.timeMonth.ceil(allDates[0]),
        d3.timeMonth.offset(d3.timeMonth.ceil(allDates[allDates.length - 1]), 1)
      );
      if (isHorizontal) {
        g.selectAll('.month-tick').data(months).enter().append('line')
          .attr('class', 'month-tick')
          .attr('x1', d => xScale(d)).attr('x2', d => xScale(d))
          .attr('y1', 0).attr('y2', height)
          .attr('stroke', '#ddd').attr('stroke-width', 1);
        g.selectAll('.month-label').data(months).enter().append('text')
          .attr('class', 'month-label')
          .attr('x', d => xScale(d)).attr('y', -10)
          .attr('text-anchor', 'middle').attr('font-size', 11)
          .attr('fill', '#bbb').text(d => d3.timeFormat('%b')(d));
      } else {
        g.selectAll('.month-tick').data(months).enter().append('line')
          .attr('class', 'month-tick')
          .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
          .attr('x1', 0).attr('x2', width)
          .attr('stroke', '#ddd').attr('stroke-width', 1);
        g.selectAll('.month-label').data(months).enter().append('text')
          .attr('class', 'month-label')
          .attr('x', -10).attr('y', d => yScale(d) + 4)
          .attr('text-anchor', 'end').attr('font-size', 11)
          .attr('fill', '#bbb').text(d => d3.timeFormat('%b')(d));
      }

      // Today line
      const today = new Date();
      if (today >= allDates[0] && today <= allDates[allDates.length - 1]) {
        const linePos = isHorizontal ? xScale(today) : yScale(today);
        g.append('line')
          .attr('class', 'today-line')
          .attr(isHorizontal ? 'x1' : 'y1', linePos)
          .attr(isHorizontal ? 'x2' : 'y2', linePos)
          .attr(isHorizontal ? 'y1' : 'x1', 0)
          .attr(isHorizontal ? 'y2' : 'x2', isHorizontal ? height : width);
      }
      g.selectAll('.today-line').lower();
      g.selectAll('.track-line').raise();
      g.selectAll('.track-label').raise();
      g.selectAll('g').raise();
    }

    render();
    window.addEventListener('resize', render);
  </script>

  <footer class="footer">
    <a href="https://github.com/velitchko/eurovis-timeline" target="_blank">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="black">
        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.6-.18-3.29-.8-3.29-3.56 0-.79.28-1.43.74-1.93-.07-.18-.32-.91.07-1.89 0 0 .6-.19 1.97.73a6.8 6.8 0 0 1 1.8-.24c.61 0 1.22.08 1.8.24 1.37-.92 1.97-.73 1.97-.73.39.98.14 1.71.07 1.89.46.5.74 1.14.74 1.93 0 2.77-1.69 3.38-3.3 3.56.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.19 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
      </svg>
    </a>
  </footer>
</body>
</html>
